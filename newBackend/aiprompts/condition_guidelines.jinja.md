Guidelines by type: Dates & durations: Never use new Date(non-ISO). Use parseDate (below) for dd/mm/yyyy, yyyy-mm-dd, Date, timestamp. Now/today = current UTC. Support differences in years|days|hours. For age, compute UTC age. For "Now - <date> > N years": if <date> is a Date of Birth, compute age in UTC; otherwise compute calendar-year difference with month/day correction. If unclear, ask a question. Email: trim+lowercase; regex ^[^\s@]+@[^\s@]+\.[^\s@]+$. Phone: keep leading +, strip non-digits; length>=9. Strings: trim and collapse whitespace; case-insensitive unless specified. Numbers: CRITICAL - Values from ctx["key"] may be strings (from HTML inputs). ALWAYS convert with Number(ctx["key"]) and check Number.isFinite(...) before comparison. Example: const month = Number(ctx["data A.Month"]); if (!Number.isFinite(month)) return false; return month === 2; NEVER use ctx["key"] === 2 directly. Mini-DSL: AGE(ctx["<key>"]) >= N ; Now - ctx["<dateKey>"] > N years|days|hours ; ctx["<dateA>"] before|after (ctx["<dateB>"]|Now) ; is valid email/phone ; ctx["<strKey>"] contains|equals "<text>" (case-insensitive by default).

Helper function (copy verbatim when dates are involved):
function parseDate(v){ if(v instanceof Date&&!Number.isNaN(v.valueOf()))return v; if(typeof v==="number"&&Number.isFinite(v))return new Date(v); if(typeof v==="string"){ const s=v.trim(); let m=s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/); if(m){ let d=parseInt(m[1],10),mo=parseInt(m[2],10)-1,y=parseInt(m[3],10); if(y<100)y+=2000; const dt=new Date(Date.UTC(y,mo,d)); return (dt.getUTCFullYear()===y&&dt.getUTCMonth()===mo&&dt.getUTCDate()===d)?dt:null; } m=s.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/); if(m){ const y=parseInt(m[1],10),mo=parseInt(m[2],10)-1,d=parseInt(m[3],10); const dt=new Date(Date.UTC(y,mo,d)); return (dt.getUTCFullYear()===y&&dt.getUTCMonth()===mo&&dt.getUTCDate()===d)?dt:null; } const iso=/^\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}(?::\d{2})?(?:\.\d+)?(?:Z|[+\-]\d{2}:\d{2})?)?$/; if(iso.test(s)){ const tt=Date.parse(s); if(!Number.isNaN(tt)) return new Date(tt); } } return null; }

