// Executive summary: Renders the tree structure of response nodes and manages their state and drag & drop logic.
import React, { useRef, useState, useEffect } from 'react';
import TreeNode from './TreeNode';
import { TreeNodeProps } from './types';
import { useDrop, useDragLayer } from 'react-dnd';
import { Plus } from 'lucide-react';

// Sposto defaultNodes fuori dal componente
const defaultNodes: TreeNodeProps[] = [
  { id: '1', text: "What is the patient's date of birth?", type: 'root' },
  { id: '2', text: "I didn't understand. Could you provide the patient's date of birth?", type: 'nomatch', level: 1, parentId: '1' },
  { id: '3', text: "Please provide the patient's date of birth.", type: 'noinput', level: 1, parentId: '1' }
];

interface TreeViewProps {
  nodes: TreeNodeProps[];
  onDrop: (targetId: string | null, position: 'before' | 'after' | 'child', item: any) => void;
  onRemove: (id: string) => void;
  onToggleInclude?: (id: string) => void; // Aggiunto per passare la funzione di toggle
  bgColor?: string; // nuovo prop opzionale
}

const renderTree = (
  nodes: TreeNodeProps[],
  parentId: string | undefined,
  level: number,
  selectedNodeId: string | null,
  onDrop: TreeViewProps['onDrop'],
  onRemove: TreeViewProps['onRemove'],
  setSelectedNodeId: (id: string | null) => void,
  stepKey?: string, // aggiunto per propagare lo step corrente
  extraProps?: Partial<TreeViewProps> & { foreColor?: string; bgColor?: string },
  singleEscalationSteps: string[] = ['start', 'success', 'confirmation']
) => {
  return nodes
    .filter(node => node.parentId === parentId)
    .map((node, idx, siblings) => {
      // Se escalation, calcola la label dinamica solo tra escalation dello stesso step
      let escalationLabel = undefined;
      if (node.type === 'escalation') {
        // Trova tutte le escalation tra i siblings (già filtrati per step/tab)
        const allEscalations = siblings.filter(n => n.type === 'escalation');
        const escIdx = allEscalations.findIndex(n => n.id === node.id);
        escalationLabel = `${escIdx + 1}° recovery`;
      }
      // Se escalation, raccogli i figli
      const childrenNodes = node.type === 'escalation'
        ? nodes.filter(n => n.parentId === node.id).map(child => ({ ...child, level: level + 1 }))
        : undefined;
      // Calcola se questa escalation è l'unica nello step e lo step è single-escalation
      let isSingleEscalation = false;
      if (node.type === 'escalation' && stepKey && singleEscalationSteps.includes(stepKey)) {
        const escCount = siblings.filter(n => n.type === 'escalation').length;
        if (escCount === 1) isSingleEscalation = true;
      }
      return (
        <React.Fragment key={node.id}>
          <TreeNode
            {...node}
            level={level}
            selected={selectedNodeId === node.id}
            onDrop={(id, position, item) => {
              const safePosition = (position === 'before' || position === 'after' || position === 'child') ? position : 'after';
              const result = onDrop(id, safePosition, item);
              if (typeof result === 'string') {
                setSelectedNodeId(result);
              } else {
                setSelectedNodeId(id);
              }
            }}
            onCancelNewNode={onRemove}
            domId={'tree-node-' + node.id}
            currentStep={stepKey}
            {...(node.type === 'escalation' ? { childrenNodes, escalationLabel, included: node.included, onToggleInclude: extraProps?.onToggleInclude, isSingleEscalation, foreColor: extraProps?.foreColor, bgColor: extraProps?.bgColor } : {})}
          />
          {/* Solo se non escalation, ricorsione classica */}
          {node.type !== 'escalation' && renderTree(nodes, node.id, level + 1, selectedNodeId, onDrop, onRemove, setSelectedNodeId, stepKey, extraProps, singleEscalationSteps)}
        </React.Fragment>
      );
    });
};

const TreeView: React.FC<TreeViewProps & { onAddEscalation?: () => void; stepKey?: string; foreColor?: string; bgColor?: string }> = ({ nodes, onDrop, onRemove, onAddEscalation, onToggleInclude, stepKey, foreColor, bgColor }) => {
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);
  // Drop preview state
  const [dropPreviewIdx, setDropPreviewIdx] = useState<number | null>(null);
  const [dropPreviewPosition, setDropPreviewPosition] = useState<'before' | 'after' | null>(null);

  // AGGIUNTA: Debug logging
  useEffect(() => {
    console.log(`[TREEVIEW DEBUG] dropPreviewIdx=${dropPreviewIdx}, dropPreviewPosition=${dropPreviewPosition}`);
    if (dropPreviewIdx !== null && nodes[dropPreviewIdx]) {
      console.log(`[TREEVIEW DEBUG] Target node:`, nodes[dropPreviewIdx]);
    }
  }, [dropPreviewIdx, dropPreviewPosition, nodes]);

  // Drop su canvas (aggiungi come root)
  const [{ isOver }, dropRef] = useDrop({
    accept: 'ACTION',
    drop(item: any, monitor) {
      if (item && typeof item === 'object') {
        const clientOffset = monitor.getClientOffset();
        if (!clientOffset) {
          setDropPreviewIdx(null); setDropPreviewPosition(null);
          return;
        }
        const containerRect = containerRef.current?.getBoundingClientRect();
        if (!containerRect) {
          setDropPreviewIdx(null); setDropPreviewPosition(null);
          return;
        }
        const y = clientOffset.y - containerRect.top;
        // Trova il nodo più vicino al punto di drop
        let closestIdx = -1;
        let minDist = Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        nodes.forEach((node, idx) => {
          const nodeElem = document.getElementById('tree-node-' + node.id);
          if (nodeElem) {
            const rect = nodeElem.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2 - containerRect.top;
            if (centerY < minY) minY = centerY;
            if (centerY > maxY) maxY = centerY;
            const dist = Math.abs(centerY - y);
            if (dist < minDist) {
              minDist = dist;
              closestIdx = idx;
            }
          }
        });
        // Se non ci sono nodi, aggiungi come root
        if (nodes.length === 0) {
          setDropPreviewIdx(null); setDropPreviewPosition(null);
          onDrop(null, 'after', item);
          setSelectedNodeId(null);
          return;
        }
        // Se il punto di drop è sopra il primo nodo o sotto l'ultimo nodo, aggiungi come root
        if (y < minY - 16 || y > maxY + 16) { // 16px di tolleranza
          setDropPreviewIdx(null); setDropPreviewPosition(null);
          onDrop(null, 'after', item);
          setSelectedNodeId(null);
          return;
        }
        // Altrimenti, drop tra i nodi
        let position: 'before' | 'after' | 'child' = 'after';
        if (closestIdx !== -1) {
          const nodeElem = document.getElementById('tree-node-' + nodes[closestIdx].id);
          if (nodeElem) {
            const rect = nodeElem.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2 - containerRect.top;
            position = y < centerY ? 'before' : 'after';
            setDropPreviewIdx(closestIdx);
            setDropPreviewPosition(position);
            const result = onDrop(nodes[closestIdx].id, position, item);
            setDropPreviewIdx(null); setDropPreviewPosition(null);
            if (typeof result === 'string') {
              setSelectedNodeId(result);
            } else {
              setSelectedNodeId(nodes[closestIdx].id);
            }
            return;
          }
        }
        setDropPreviewIdx(null); setDropPreviewPosition(null);
      }
    },
    hover(item, monitor) {
      // AGGIUNTA: Debug per capire il tipo di drag
      console.log(`[DRAG DEBUG] Item being dragged:`, item);
      console.log(`[DRAG DEBUG] Item type:`, item?.type);
      console.log(`[DRAG DEBUG] Item id:`, item?.id);
      
      // CORREZIONE: Distingui tra nuova azione e azione esistente
      const isNewAction = item?.action; // Nuova azione ha 'action' property
      const isExistingAction = item?.id && !item?.action; // Azione esistente ha solo 'id'
      
      console.log(`[DRAG DEBUG] Is new action:`, isNewAction);
      console.log(`[DRAG DEBUG] Is existing action:`, isExistingAction);
      
      const clientOffset = monitor.getClientOffset();
      if (!clientOffset) { setDropPreviewIdx(null); setDropPreviewPosition(null); return; }
      const containerRect = containerRef.current?.getBoundingClientRect();
      if (!containerRect) { setDropPreviewIdx(null); setDropPreviewPosition(null); return; }
      const y = clientOffset.y - containerRect.top;
      
      // LOGICA SPECIFICA PER NUOVE AZIONI
      if (isNewAction) {
        console.log(`[DRAG DEBUG] Handling NEW ACTION drag`);
        
        // Trova il nodo più vicino
        let closestIdx = -1;
        let minDist = Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        
        nodes.forEach((node, idx) => {
          const nodeElem = document.getElementById('tree-node-' + node.id);
          if (nodeElem) {
            const rect = nodeElem.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2 - containerRect.top;
            if (centerY < minY) minY = centerY;
            if (centerY > maxY) maxY = centerY;
            const dist = Math.abs(centerY - y);
            if (dist < minDist) {
              minDist = dist;
              closestIdx = idx;
            }
          }
        });
        
        if (nodes.length === 0) { setDropPreviewIdx(null); setDropPreviewPosition(null); return; }
        if (y < minY - 16 || y > maxY + 16) { setDropPreviewIdx(null); setDropPreviewPosition(null); return; }
        
        if (closestIdx !== -1) {
          const targetNode = nodes[closestIdx];
          const nodeElem = document.getElementById('tree-node-' + targetNode.id);
          
          if (nodeElem) {
            const rect = nodeElem.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2 - containerRect.top;
            const position = y < centerY ? 'before' : 'after';
            
            // REGOLA 4: Se è un escalation e stiamo trascinando sopra lo spazio tra due recovery, non mostrare preview
            if (targetNode.type === 'escalation') {
              // Calcola se siamo nello spazio tra recovery (non dentro un recovery)
              const headerHeight = 40;
              const padding = 8;
              const nodeTop = nodeElem.offsetTop;
              const nodeHeight = nodeElem.offsetHeight;
              const headerBottom = nodeTop + headerHeight + padding;
              const nodeBottom = nodeTop + nodeHeight;
              
              // Se siamo sopra l'header o sotto il nodo, non mostrare preview
              if (y < headerBottom || y > nodeBottom) {
                console.log(`[DRAG DEBUG] Between escalations - no preview`);
                setDropPreviewIdx(null);
                setDropPreviewPosition(null);
                return;
              }
            }
            
            // REGOLA 1-3: Mostra preview per azioni dentro recovery
            console.log(`[DRAG DEBUG] Showing preview for new action at node ${targetNode.id}, position: ${position}`);
            setDropPreviewIdx(closestIdx);
            setDropPreviewPosition(position);
            return;
          }
        }
      }
      
      // LOGICA SPECIFICA PER AZIONI ESISTENTI (REORDERING)
      if (isExistingAction) {
        console.log(`[DRAG DEBUG] Handling EXISTING ACTION reordering`);
        
        // Per reordering, permette preview ovunque tranne tra escalation
        let closestIdx = -1;
        let minDist = Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        
        nodes.forEach((node, idx) => {
          const nodeElem = document.getElementById('tree-node-' + node.id);
          if (nodeElem) {
            const rect = nodeElem.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2 - containerRect.top;
            if (centerY < minY) minY = centerY;
            if (centerY > maxY) maxY = centerY;
            const dist = Math.abs(centerY - y);
            if (dist < minDist) {
              minDist = dist;
              closestIdx = idx;
            }
          }
        });
        
        if (nodes.length === 0) { setDropPreviewIdx(null); setDropPreviewPosition(null); return; }
        if (y < minY - 16 || y > maxY + 16) { setDropPreviewIdx(null); setDropPreviewPosition(null); return; }
        
        if (closestIdx !== -1) {
          const targetNode = nodes[closestIdx];
          const nodeElem = document.getElementById('tree-node-' + targetNode.id);
          
          if (nodeElem) {
            const rect = nodeElem.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2 - containerRect.top;
            const position = y < centerY ? 'before' : 'after';
            
            // Per reordering, mostra sempre preview (anche tra escalation)
            console.log(`[DRAG DEBUG] Showing preview for existing action reordering at node ${targetNode.id}, position: ${position}`);
            setDropPreviewIdx(closestIdx);
            setDropPreviewPosition(position);
            return;
          }
        }
      }
      
      setDropPreviewIdx(null);
      setDropPreviewPosition(null);
    },
    collect: monitor => ({
      isOver: monitor.isOver({ shallow: true })
    })
  });

  // Ghost custom (già presente)
  const CustomDragLayer: React.FC<{ nodes: TreeNodeProps[] }> = ({ nodes }) => {
    const { isDragging, item, currentOffset } = useDragLayer((monitor) => ({
      isDragging: monitor.isDragging(),
      item: monitor.getItem(),
      currentOffset: monitor.getSourceClientOffset(),
    }));
    if (!isDragging || !item || !currentOffset) return null;
    const draggedNode = nodes.find(n => n.id === item.id);
    if (!draggedNode) return null;
    const previewText = (draggedNode.text || draggedNode.label || '').slice(0, 30) + (draggedNode.text && draggedNode.text.length > 30 ? '...' : '');
    return (
      <div style={{
        position: 'fixed',
        pointerEvents: 'none',
        left: currentOffset.x,
        top: currentOffset.y,
        zIndex: 1000,
        transform: 'translate(-50%, -50%)',
        background: '#fff',
        border: '2px solid #2563eb',
        borderRadius: 6,
        boxShadow: '0 4px 16px rgba(0,0,0,0.15)',
        padding: '8px 16px',
        minWidth: 120,
        maxWidth: 240,
        fontWeight: 500,
        fontSize: 15,
        color: '#222',
        opacity: 0.95
      }}>
        {previewText}
      </div>
    );
  };

  return (
    <div
      ref={node => { dropRef(node); containerRef.current = node; }}
      className="h-full flex flex-col"
      style={{
        position: 'relative',
        minHeight: 200,
        border: isOver ? '2px solid #60a5fa' : '2px solid transparent',
        transition: 'border 0.2s',
        background: isOver ? 'rgba(96,165,250,0.08)' : undefined
      }}
    >
      <CustomDragLayer nodes={nodes} />
      
      {/* Drop preview lines - AGGIUNTA CRITICA */}
      {dropPreviewIdx !== null && dropPreviewPosition && (
        <div style={{
          position: 'absolute',
          left: 0,
          right: 0,
          height: 3,
          background: '#2563eb',
          zIndex: 1000,
          pointerEvents: 'none',
          top: dropPreviewPosition === 'before' ? 
            (() => {
              const targetNode = nodes[dropPreviewIdx];
              const nodeElem = document.getElementById('tree-node-' + targetNode.id);
              
                             // Se è un escalation, calcola la posizione basandosi sulle azioni interne
               const childrenNodes = targetNode.type === 'escalation' 
                 ? nodes.filter(n => n.parentId === targetNode.id).map(child => ({ ...child, level: 1 }))
                 : undefined;
               console.log(`[DEBUG] Target node type: ${targetNode.type}, calculated childrenNodes:`, childrenNodes);
               if (targetNode.type === 'escalation' && childrenNodes && childrenNodes.length > 0) {
                 console.log(`[DEBUG] Found escalation with children:`, childrenNodes);
                 // Trova la prima azione interna per calcolare la posizione
                 const firstAction = childrenNodes[0];
                                 if (firstAction) {
                   // Calcola la posizione basandosi sulla struttura del nodo escalation
                   // Header escalation (circa 40px) + padding (circa 8px) + prima azione
                   const headerHeight = 40; // Altezza approssimativa dell'header escalation
                   const padding = 8;
                   const actionHeight = 32; // Altezza approssimativa di ogni ActionRow
                   
                   const top = nodeElem ? nodeElem.offsetTop + headerHeight + padding - 2 : 0;
                   console.log(`[PREVIEW DEBUG] Escalation ${targetNode.id}, first action before position: ${top}px (calculated)`);
                   return top;
                 }
              }
              
              // Fallback: usa il nodo escalation
              const top = nodeElem ? nodeElem.offsetTop - 2 : 0;
              console.log(`[PREVIEW DEBUG] Node ${targetNode.id}, before position: ${top}px`);
              return top;
            })() : 
            (() => {
              const targetNode = nodes[dropPreviewIdx];
              const nodeElem = document.getElementById('tree-node-' + targetNode.id);
              
                             // Se è un escalation, calcola la posizione basandosi sulle azioni interne
               const childrenNodes = targetNode.type === 'escalation' 
                 ? nodes.filter(n => n.parentId === targetNode.id).map(child => ({ ...child, level: 1 }))
                 : undefined;
               if (targetNode.type === 'escalation' && childrenNodes && childrenNodes.length > 0) {
                 console.log(`[DEBUG] Found escalation with children (after):`, childrenNodes);
                 // Trova l'ultima azione interna per calcolare la posizione
                 const lastAction = childrenNodes[childrenNodes.length - 1];
                                 if (lastAction) {
                   // Calcola la posizione basandosi sulla struttura del nodo escalation
                   // Header escalation (circa 40px) + padding (circa 8px) + tutte le azioni + padding finale
                   const headerHeight = 40; // Altezza approssimativa dell'header escalation
                   const padding = 8;
                   const actionHeight = 32; // Altezza approssimativa di ogni ActionRow
                   const totalActionsHeight = childrenNodes.length * actionHeight;
                   
                   const top = nodeElem ? nodeElem.offsetTop + headerHeight + padding + totalActionsHeight + padding + 2 : 0;
                   console.log(`[PREVIEW DEBUG] Escalation ${targetNode.id}, last action after position: ${top}px (calculated)`);
                   return top;
                 }
              }
              
              // Fallback: usa il nodo escalation
              const top = nodeElem ? nodeElem.offsetTop + nodeElem.offsetHeight + 2 : 0;
              console.log(`[PREVIEW DEBUG] Node ${targetNode.id}, after position: ${top}px`);
              return top;
            })()
        }} />
      )}
      
      <div>
        {renderTree(nodes, undefined, 0, selectedNodeId, onDrop, onRemove, setSelectedNodeId, stepKey, { onToggleInclude, foreColor, bgColor })}
      </div>
      {/* Bottone aggiungi escalation in fondo se ci sono escalation visibili */}
      {onAddEscalation && nodes.some(n => n.type === 'escalation') && (
        <div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: 18 }}>
          <button
            onClick={onAddEscalation}
            style={{
              color: foreColor || '#ef4444',
              border: `1.5px solid ${foreColor || '#ef4444'}`,
              background: bgColor || 'rgba(239,68,68,0.08)',
              borderRadius: 999,
              padding: '5px 18px',
              fontWeight: 700,
              fontSize: 15,
              display: 'inline-flex',
              alignItems: 'center',
              gap: 8,
              cursor: 'pointer',
              marginTop: 8
            }}
          >
            <Plus size={18} style={{ marginRight: 6 }} />
            {stepKey === 'confirmation' ? 'Aggiungi conferma' : 'Aggiungi recovery'}
          </button>
        </div>
      )}
    </div>
  );
};

export default TreeView; 