import React, { useRef, useState } from 'react';
import type { SchemaNode } from './MainDataCollection';
import { Pencil, Trash2, Plus, Check, X, User, MapPin, Calendar, Type as TypeIcon, Mail, Phone, Hash, Globe, Home, Building, FileText, HelpCircle, Link, ChevronDown, ChevronRight } from 'lucide-react';

interface MainDataWizardProps {
  node: SchemaNode;
  onChange: (node: SchemaNode) => void;
  onRemove: () => void;
  // onAddSub removed (plus now lives near the pencil)
  selected?: boolean;
  autoEdit?: boolean;
  pathPrefix?: string;
  onChangeEvent?: (e: { type: string; path: string; payload?: any }) => void;
  onRequestOpen?: () => void;
}

const iconBtn: React.CSSProperties = { background: 'transparent', border: 'none', padding: 0, cursor: 'pointer' };

const MainDataWizard: React.FC<MainDataWizardProps & { progressByPath?: Record<string, number> }> = ({ node, onChange, onRemove, progressByPath, selected, autoEdit, pathPrefix = '', onChangeEvent, onRequestOpen }) => {
  // Ensure open on demand (e.g., pencil click) in addition to selection
  const [forceOpen, setForceOpen] = useState(false);
  const [isEditingMain, setIsEditingMain] = useState(!!autoEdit);
  const [labelDraft, setLabelDraft] = useState(autoEdit ? '' : (node.label || ''));
  const [hoverHeader, setHoverHeader] = useState(false);
  const [editingSubIdx, setEditingSubIdx] = useState<number | null>(null);
  const [hoverSubIdx, setHoverSubIdx] = useState<number | null>(null);
  const [subDraft, setSubDraft] = useState<string>('');
  const [hoverMainConstraints, setHoverMainConstraints] = useState(false);
  const [editingConstraint, setEditingConstraint] = useState<
    | { scope: 'main'; idx: number }
    | { scope: 'sub'; subIdx: number; idx: number }
    | null
  >(null);
  const lastAddedConstraintRef = useRef<null | { scope: 'main' | 'sub'; idx: number; subIdx?: number }>(null);
  // Label will be generated by AI; we only collect an explanation
  // no-op state for compatibility with handlers that set it
  const [, setConstraintTitleDraft] = useState<string>('');
  const [constraintPayoffDraft, setConstraintPayoffDraft] = useState('');

  const renderIcon = (name?: string, size: number = 16) => {
    const color = '#fb923c';
    switch ((name || '').trim()) {
      case 'User': return <User size={size} color={color} />;
      case 'MapPin': return <MapPin size={size} color={color} />;
      case 'Calendar': return <Calendar size={size} color={color} />;
      case 'Type': return <TypeIcon size={size} color={color} />;
      case 'Mail': return <Mail size={size} color={color} />;
      case 'Phone': return <Phone size={size} color={color} />;
      case 'Hash': return <Hash size={size} color={color} />;
      case 'Globe': return <Globe size={size} color={color} />;
      case 'Home': return <Home size={size} color={color} />;
      case 'Building': return <Building size={size} color={color} />;
      case 'HelpCircle': return <HelpCircle size={size} color={color} />;
      case 'FileText':
      default:
        return <FileText size={size} color={color} />;
    }
  };

  const commitMain = async () => {
    console.log('[MAIN_DATA_WIZARD] üéØ commitMain called with:', {
      labelDraft,
      currentLabel: node.label,
      isChanged: (node.label || '') !== labelDraft
    });

    // üöÄ NEW: Call AI for single field analysis
    if (labelDraft.trim()) {
      console.log('[MAIN_DATA_WIZARD] ü§ñ Calling AI for field:', labelDraft);
      try {
        const response = await fetch('/step2-with-provider', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userDesc: labelDraft })
        });
        const data = await response.json();
        console.log('[MAIN_DATA_WIZARD] ü§ñ AI Response:', data);

        if (data.ai?.mains?.[0]) {
          const aiField = data.ai.mains[0];
          console.log('[MAIN_DATA_WIZARD] üéØ Using AI field structure:', aiField);

          // Update node with AI structure
          const updatedNode = {
            ...node,
            label: aiField.label || labelDraft,
            type: aiField.type || 'text',
            icon: aiField.icon || 'FileText',
            subData: aiField.subData || [],
            validation: aiField.validation || {},
            example: aiField.example || ''
          };

          console.log('[MAIN_DATA_WIZARD] üìù Updating node with AI structure:', updatedNode);
          onChange(updatedNode);
          onChangeEvent?.({ type: 'main.renamed', path: updatedNode.label, payload: { oldPath: node.label || '' } });
          setIsEditingMain(false);
          return;
        }
      } catch (error) {
        console.error('[MAIN_DATA_WIZARD] ‚ùå AI call failed:', error);
      }
    }

    // Fallback to original logic
    setIsEditingMain(false);
    if ((node.label || '') !== labelDraft) {
      const old = node.label || '';
      console.log('[MAIN_DATA_WIZARD] üìù Updating node label from', old, 'to', labelDraft);
      onChange({ ...node, label: labelDraft });
      console.log('[MAIN_DATA_WIZARD] üîî Triggering changeEvent: main.renamed');
      onChangeEvent?.({ type: 'main.renamed', path: labelDraft, payload: { oldPath: old } });
    } else {
      console.log('[MAIN_DATA_WIZARD] ‚è≠Ô∏è No change detected, skipping update');
    }
  };

  const cancelMain = () => {
    setIsEditingMain(false);
    setLabelDraft(node.label || '');
  };

  const startEditSub = (idx: number, current: string) => {
    setEditingSubIdx(idx);
    setSubDraft(current || '');
  };

  const commitSub = (idx: number) => {
    const next = { ...node, subData: Array.isArray(node.subData) ? node.subData.slice() : [] } as SchemaNode;
    const old = String((next.subData![idx] as any)?.label || '');
    next.subData![idx] = { ...(next.subData![idx] || { label: '' }), label: subDraft } as SchemaNode;
    onChange(next);
    setEditingSubIdx(null);
    setSubDraft('');
    if (old !== subDraft) onChangeEvent?.({ type: 'sub.renamed', path: `${pathPrefix}/${subDraft}`, payload: { oldPath: `${pathPrefix}/${old}` } });
  };

  const cancelSub = () => {
    setEditingSubIdx(null);
    setSubDraft('');
  };

  const ensureMainConstraints = () => Array.isArray(node.constraints) ? node.constraints.slice() : [];
  const ensureSubConstraints = (subIdx: number) => {
    const sub = (node.subData || [])[subIdx];
    const arr = sub && Array.isArray(sub.constraints) ? sub.constraints.slice() : [];
    return arr;
  };

  const handleQuickAddSub = () => {
    const next = { ...node, subData: Array.isArray(node.subData) ? node.subData.slice() : [] } as SchemaNode;
    next.subData!.push({ label: '', type: 'text', icon: 'FileText' } as any);
    onChange(next);
    // enter inline edit on the newly added sub
    setEditingSubIdx((next.subData!.length - 1));
    setSubDraft('');
    onChangeEvent?.({ type: 'sub.added', path: `${pathPrefix}/${(next.subData![next.subData!.length - 1] as any)?.label || 'sub'}` });
  };

  const addMainConstraint = () => {
    const next = { ...node } as SchemaNode;
    const list = ensureMainConstraints();
    const newIdx = list.length;
    list.push({ kind: 'length', title: '', payoff: '' } as any);
    next.constraints = list;
    onChange(next);
    setEditingConstraint({ scope: 'main', idx: newIdx });
    setConstraintTitleDraft('');
    setConstraintPayoffDraft('');
    lastAddedConstraintRef.current = { scope: 'main', idx: newIdx };
    onChangeEvent?.({ type: 'constraint.added', path: `${pathPrefix}::constraint#${newIdx}` });
  };

  const addSubConstraint = (subIdx: number) => {
    const next = { ...node, subData: Array.isArray(node.subData) ? node.subData.slice() : [] } as SchemaNode;
    const sub = { ...(next.subData?.[subIdx] || {}) } as any;
    const list = Array.isArray(sub.constraints) ? sub.constraints.slice() : [];
    const newIdx = list.length;
    list.push({ kind: 'length', title: '', payoff: '' } as any);
    sub.constraints = list;
    (next.subData as any)[subIdx] = sub;
    onChange(next);
    setEditingConstraint({ scope: 'sub', subIdx, idx: newIdx });
    setConstraintTitleDraft('');
    setConstraintPayoffDraft('');
    lastAddedConstraintRef.current = { scope: 'sub', subIdx, idx: newIdx };
    onChangeEvent?.({ type: 'constraint.added', path: `${pathPrefix}/${(next.subData?.[subIdx] as any)?.label || 'sub'}::constraint#${newIdx}` });
  };

  const startEditConstraint = (scope: 'main' | 'sub', idx: number, subIdx?: number) => {
    if (scope === 'main') {
      const c = ensureMainConstraints()[idx];
      setConstraintTitleDraft(c?.title || '');
      setConstraintPayoffDraft(c?.payoff || '');
      setEditingConstraint({ scope: 'main', idx });
    } else if (typeof subIdx === 'number') {
      const c = ensureSubConstraints(subIdx)[idx];
      setConstraintTitleDraft(c?.title || '');
      setConstraintPayoffDraft(c?.payoff || '');
      setEditingConstraint({ scope: 'sub', subIdx, idx });
    }
  };

  const commitConstraint = () => {
    if (!editingConstraint) return;
    if (editingConstraint.scope === 'main') {
      const list = ensureMainConstraints();
      if (list[editingConstraint.idx]) {
        list[editingConstraint.idx] = { ...list[editingConstraint.idx], title: (list[editingConstraint.idx] as any)?.title || '', payoff: constraintPayoffDraft } as any;
        onChange({ ...node, constraints: list });
      }
    } else {
      const { subIdx, idx } = editingConstraint as any;
      const next = { ...node, subData: Array.isArray(node.subData) ? node.subData.slice() : [] } as SchemaNode;
      const sub = { ...(next.subData?.[subIdx] || {}) } as any;
      const list = Array.isArray(sub.constraints) ? sub.constraints.slice() : [];
      if (list[idx]) list[idx] = { ...list[idx], title: (list[idx] as any)?.title || '', payoff: constraintPayoffDraft } as any;
      sub.constraints = list;
      (next.subData as any)[subIdx] = sub;
      onChange(next);
    }
    setEditingConstraint(null);
    setConstraintTitleDraft('');
    setConstraintPayoffDraft('');
    lastAddedConstraintRef.current = null;
    onChangeEvent?.({ type: 'constraint.updated', path: `${pathPrefix}` });
  };

  const cancelConstraint = () => {
    // If the currently edited constraint was just created, remove it
    if (editingConstraint && lastAddedConstraintRef.current) {
      const a = lastAddedConstraintRef.current;
      if (a.scope === 'main' && editingConstraint.scope === 'main' && a.idx === editingConstraint.idx) {
        const list = ensureMainConstraints();
        const nextList = list.filter((_, i) => i !== a.idx);
        onChange({ ...node, constraints: nextList } as any);
        lastAddedConstraintRef.current = null;
        onChangeEvent?.({ type: 'constraint.removed', path: `${pathPrefix}::constraint#${a.idx}` });
      } else if (a.scope === 'sub' && editingConstraint.scope === 'sub' && a.idx === editingConstraint.idx && a.subIdx === editingConstraint.subIdx) {
        const next = { ...node, subData: Array.isArray(node.subData) ? node.subData.slice() : [] } as any;
        const sub = { ...(next.subData?.[a.subIdx!] || {}) };
        const list = Array.isArray(sub.constraints) ? sub.constraints.slice() : [];
        sub.constraints = list.filter((_: any, i: number) => i !== a.idx);
        next.subData[a.subIdx!] = sub;
        onChange(next);
        lastAddedConstraintRef.current = null;
        onChangeEvent?.({ type: 'constraint.removed', path: `${pathPrefix}/${(sub as any)?.label || 'sub'}::constraint#${a.idx}` });
      }
    }
    setEditingConstraint(null);
    setConstraintTitleDraft('');
    setConstraintPayoffDraft('');
  };

  const deleteConstraint = (scope: 'main' | 'sub', idx: number, subIdx?: number) => {
    if (scope === 'main') {
      const list = ensureMainConstraints();
      const nextList = list.filter((_, i) => i !== idx);
      onChange({ ...node, constraints: nextList });
    } else if (typeof subIdx === 'number') {
      const next = { ...node, subData: Array.isArray(node.subData) ? node.subData.slice() : [] } as SchemaNode;
      const sub = { ...(next.subData?.[subIdx] || {}) } as any;
      const list = Array.isArray(sub.constraints) ? sub.constraints.slice() : [];
      sub.constraints = list.filter((_: any, i: number) => i !== idx);
      (next.subData as any)[subIdx] = sub;
      onChange(next);
    }
  };

  // open ora dipende da selected
  const open = !!selected || forceOpen;

  React.useEffect(() => {
    if (!selected) setForceOpen(false);
  }, [selected]);

  return (
    <div
      style={{
        border: selected ? '4px solid #fff' : '1px solid #7c2d12',
        borderRadius: 10,
        marginBottom: 10,
        background: '#0b1220',
        boxSizing: 'border-box',
        transition: 'border 0.15s',
      }}
    >
      <div
        style={{ display: 'flex', flexDirection: 'column', padding: 12, gap: 6 }}
        onMouseEnter={() => setHoverHeader(true)}
        onMouseLeave={() => setHoverHeader(false)}
      >
        {/* üìê Riga 1: Label + Percentuale inline */}
        <div style={{ display: 'flex', alignItems: 'center', gap: 10 }}>
          {!isEditingMain ? (
            <>
              <div style={{ display: 'flex', alignItems: 'center', gap: 10, whiteSpace: 'nowrap' }}>
                <span>{renderIcon(node.icon, 16)}</span>
                <span style={{ fontWeight: 700, color: '#e2e8f0', whiteSpace: 'nowrap' }}>{node.label || 'Field'}</span>
              </div>
              {/* üìç Percentuale subito dopo il testo */}
              {(() => {
                const path = node.label;
                const val = progressByPath ? progressByPath[path] : undefined;
                if (typeof val === 'number') {
                  const percentage = Math.round(val * 100);
                  return (
                    <span style={{ fontSize: 11, color: '#93c5fd', fontWeight: 600, marginLeft: 4 }}>
                      {percentage}%
                    </span>
                  );
                }
                return null;
              })()}
              {/* Action buttons */}
              {hoverHeader && (
                <>
                  <button title="Edit" onClick={() => { setIsEditingMain(true); setLabelDraft(node.label || ''); setForceOpen(true); onRequestOpen?.(); }} style={iconBtn}>
                    <Pencil size={16} color="#fb923c" />
                  </button>
                  <button title="Add sub data" onClick={handleQuickAddSub} style={iconBtn}>
                    <Plus size={16} color="#fb923c" />
                  </button>
                  <button title="Add constraint" onClick={addMainConstraint} style={iconBtn}>
                    <Link size={14} color="#fb923c" />
                  </button>
                  <button title="Delete" onClick={onRemove} style={iconBtn}>
                    <Trash2 size={16} color="#fb923c" />
                  </button>
                </>
              )}
            </>
          ) : (
            <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
              <input
                autoFocus
                value={labelDraft}
                onChange={(e) => {
                  console.log('[MAIN_DATA_WIZARD] üî§ Label changed:', e.target.value);
                  setLabelDraft(e.target.value);
                }}
                onKeyDown={async (e) => {
                  console.log('[MAIN_DATA_WIZARD] ‚å®Ô∏è Key pressed:', e.key, 'with value:', labelDraft);
                  if (e.key === 'Enter') {
                    console.log('[MAIN_DATA_WIZARD] ‚èé Enter pressed, committing:', labelDraft);
                    await commitMain();
                  }
                  if (e.key === 'Escape') {
                    console.log('[MAIN_DATA_WIZARD] ‚éã Escape pressed, cancelling');
                    cancelMain();
                  }
                }}
                placeholder="data label ..."
                style={{ background: '#0f172a', color: '#e2e8f0', border: '1px solid #334155', borderRadius: 6, padding: '6px 10px', minWidth: 260, fontWeight: 700 }}
              />
              <button title="Confirm" onClick={async () => {
                console.log('[MAIN_DATA_WIZARD] ‚úÖ Confirm clicked, committing:', labelDraft);
                await commitMain();
              }} style={iconBtn}><Check size={18} color="#22c55e" /></button>
              <button title="Cancel" onClick={cancelMain} style={iconBtn}><X size={18} color="#ef4444" /></button>
            </div>
          )}
          {/* Chevron expand/collapse - moved to end of first row */}
          <div style={{ marginLeft: 'auto' }}>
            {Array.isArray(node.subData) && node.subData.length > 0 && (
              <button
                title={open ? 'Collapse' : 'Expand'}
                onClick={() => { setForceOpen(!open); onRequestOpen?.(); }}
                style={{ background: 'transparent', border: 'none', padding: 0, cursor: 'pointer', lineHeight: 0 }}
              >
                {open ? <ChevronDown size={20} color="#fb923c" /> : <ChevronRight size={20} color="#fb923c" />}
              </button>
            )}
          </div>
        </div>

        {/* üìê Riga 2: Barra di progresso sotto, full width */}
        {(() => {
          const path = node.label;
          const val = progressByPath ? progressByPath[path] : undefined;
          if (typeof val === 'number') {
            const percentage = Math.round(val * 100);
            const isComplete = percentage >= 100;

            // üé® Colors: light orange for in-progress, solid red/orange for complete
            const barColor = isComplete ? '#ef4444' : '#fbbf24';

            // üé® Style: dashed for in-progress, solid for complete
            const barStyle = isComplete
              ? { background: barColor }
              : {
                background: `repeating-linear-gradient(
                    to right,
                    ${barColor} 0px,
                    ${barColor} 8px,
                    transparent 8px,
                    transparent 12px
                  )`
              };

            return (
              <div style={{ width: '100%', height: 4, background: '#1f2937', borderRadius: 9999, overflow: 'hidden' }}>
                <div style={{
                  width: `${percentage}%`,
                  height: '100%',
                  ...barStyle,
                  transition: 'width 0.8s ease, background 0.3s ease'
                }} />
              </div>
            );
          }
          return null;
        })()}
      </div>
      {open && (
        <div style={{ padding: 12, paddingTop: 0 }}>
          {/* Constraints for main node */}
          <div
            onMouseEnter={() => setHoverMainConstraints(true)}
            onMouseLeave={() => setHoverMainConstraints(false)}
          >
            {(Array.isArray(node.constraints) && (node.constraints as any[]).some((c: any) => (String(c?.title || '').trim().length > 0) || (String(c?.payoff || '').trim().length > 0))) && (
              <div style={{ marginBottom: 8 }}>
                {(node.constraints as any[]).filter((c: any) => (String(c?.title || '').trim().length > 0) || (String(c?.payoff || '').trim().length > 0)).map((c: any, idx: number) => (
                  <div key={idx} style={{ display: 'flex', flexDirection: 'column', gap: 4, padding: '6px 0', width: '100%' }}>
                    {editingConstraint && editingConstraint.scope === 'main' && editingConstraint.idx === idx ? (
                      <div style={{ display: 'flex', alignItems: 'center', gap: 8, width: '100%' }}>
                        <input autoFocus value={constraintPayoffDraft} onChange={(e) => setConstraintPayoffDraft(e.target.value)} placeholder="describe the constraint ..." style={{ background: '#0f172a', color: '#e2e8f0', border: '1px solid #334155', borderRadius: 6, padding: '4px 8px', flex: 1, minWidth: 0 }} />
                        <button title="Confirm" onClick={commitConstraint} disabled={(constraintPayoffDraft || '').trim().length < 5} style={{ ...iconBtn, opacity: (constraintPayoffDraft || '').trim().length < 5 ? 0.5 : 1, cursor: (constraintPayoffDraft || '').trim().length < 5 ? 'not-allowed' : 'pointer' }}>
                          <Check size={18} color={(constraintPayoffDraft || '').trim().length < 5 ? '#64748b' : '#22c55e'} />
                        </button>
                        <button title="Cancel" onClick={cancelConstraint} style={iconBtn}><X size={18} color="#ef4444" /></button>
                      </div>
                    ) : (
                      <>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 8, width: '100%' }} onMouseEnter={() => setHoverMainConstraints(true)} onMouseLeave={() => setHoverMainConstraints(false)}>
                          {(() => {
                            const mainText = (String((c as any)?.title || '').trim() || String((c as any)?.payoff || '').trim());
                            return (
                              <span style={{ fontWeight: 600, fontSize: 14, color: '#c7d2fe', whiteSpace: 'nowrap' }}>
                                {mainText}
                              </span>
                            );
                          })()}
                          {hoverMainConstraints && (
                            <>
                              <button title="Edit" onClick={() => startEditConstraint('main', idx)} style={iconBtn}><Pencil size={14} color="#fb923c" /></button>
                              <button title="Delete" onClick={() => deleteConstraint('main', idx)} style={iconBtn}><Trash2 size={14} color="#fb923c" /></button>
                            </>
                          )}
                        </div>
                        {(String((c as any)?.payoff || '').trim().length > 0) ? (
                          <div style={{ fontSize: 14, color: '#94a3b8' }}>{(c as any).payoff}</div>
                        ) : null}
                      </>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
          {Array.isArray(node.subData) && node.subData.length > 0 ? (
            node.subData.map((s, i) => (
              <div
                key={i}
                style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 8 }}
                onMouseEnter={() => setHoverSubIdx(i)}
                onMouseLeave={() => setHoverSubIdx(curr => (curr === i ? null : curr))}
              >
                {editingSubIdx === i ? (
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                    <input
                      autoFocus
                      value={subDraft}
                      onChange={(e) => setSubDraft(e.target.value)}
                      onKeyDown={(e) => { if (e.key === 'Enter') commitSub(i); if (e.key === 'Escape') cancelSub(); }}
                      placeholder="subdata label ..."
                      style={{ background: '#0f172a', color: '#e2e8f0', border: '1px solid #334155', borderRadius: 6, padding: '6px 10px', minWidth: 280 }}
                    />
                    <button title="Confirm" onClick={() => commitSub(i)} style={iconBtn}><Check size={18} color="#22c55e" /></button>
                    <button title="Cancel" onClick={cancelSub} style={iconBtn}><X size={18} color="#ef4444" /></button>
                  </div>
                ) : (
                  <div style={{ display: 'flex', flexDirection: 'column', width: '100%' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 8, width: '100%' }}>
                      <span>{renderIcon(s.icon, 14)}</span>
                      <span style={{ color: '#e2e8f0', whiteSpace: 'nowrap' }}>{s.label || 'Field'}</span>
                      {hoverSubIdx === i && (
                        <>
                          <button title="Add constraint" onClick={() => addSubConstraint(i)} style={{ ...iconBtn, color: '#fb923c' }}>
                            <Link size={14} color="#fb923c" />
                          </button>
                          <button title="Edit" onClick={() => startEditSub(i, s.label || '')} style={iconBtn}>
                            <Pencil size={16} color="#fb923c" />
                          </button>
                          <button title="Delete" onClick={() => onChange({ ...node, subData: node.subData!.filter((_, x) => x !== i) })} style={iconBtn}>
                            <Trash2 size={16} color="#fb923c" />
                          </button>
                        </>
                      )}
                      <div style={{ flex: 1 }} />
                    </div>
                    {/* sub progress bar with percentage text (under label, aligned left) */}
                    {(() => {
                      const path = `${node.label}/${s.label}`;
                      const val = progressByPath ? progressByPath[path] : undefined;
                      if (typeof val === 'number') {
                        return (
                          <div style={{ display: 'flex', alignItems: 'center', gap: 8, margin: '4px 0 0 22px', width: 'calc(100% - 22px)' }}>
                            <div style={{ flex: 1, height: 3, background: '#1f2937', borderRadius: 9999, overflow: 'hidden' }}>
                              <div style={{ width: `${Math.round(val * 100)}%`, height: '100%', background: '#fb923c', transition: 'width 0.8s ease' }} />
                            </div>
                            <span style={{ fontSize: 10, color: '#93c5fd', minWidth: 28, textAlign: 'left' }}>{Math.round(val * 100)}%</span>
                          </div>
                        );
                      }
                      return null;
                    })()}

                    {(() => {
                      const useful = (Array.isArray(s.constraints) ? s.constraints : [])
                        .filter((c: any) => (String(c?.title || '').trim().length > 0) || (String(c?.payoff || '').trim().length > 0));
                      if (useful.length === 0) return null;
                      return (
                        <div style={{ marginLeft: 20 }}>
                          {useful.map((c, j) => (
                            <div key={`c-${i}-${j}`} style={{ display: 'flex', flexDirection: 'column', gap: 4, padding: '6px 0', width: '100%' }}>
                              {editingConstraint && editingConstraint.scope === 'sub' && (editingConstraint as any).subIdx === i && editingConstraint.idx === j ? (
                                <div style={{ display: 'flex', alignItems: 'center', gap: 8, width: '100%' }}>
                                  <input autoFocus value={constraintPayoffDraft} onChange={(e) => setConstraintPayoffDraft(e.target.value)} placeholder="describe the constraint ..." style={{ background: '#0f172a', color: '#e2e8f0', border: '1px solid #334155', borderRadius: 6, padding: '4px 8px', flex: 1, minWidth: 0 }} />
                                  <button title="Confirm" onClick={commitConstraint} disabled={(constraintPayoffDraft || '').trim().length < 5} style={{ ...iconBtn, opacity: (constraintPayoffDraft || '').trim().length < 5 ? 0.5 : 1, cursor: (constraintPayoffDraft || '').trim().length < 5 ? 'not-allowed' : 'pointer' }}>
                                    <Check size={18} color={(constraintPayoffDraft || '').trim().length < 5 ? '#64748b' : '#22c55e'} />
                                  </button>
                                  <button title="Cancel" onClick={cancelConstraint} style={iconBtn}><X size={18} color="#ef4444" /></button>
                                </div>
                              ) : (
                                <>
                                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, width: '100%' }} onMouseEnter={() => setHoverSubIdx(i)} onMouseLeave={() => setHoverSubIdx(curr => (curr === i ? null : curr))}>
                                    {(() => {
                                      const mainText = (String((c as any)?.title || '').trim() || String((c as any)?.payoff || '').trim());
                                      return (
                                        <span style={{ fontWeight: 600, fontSize: 14, color: '#c7d2fe', whiteSpace: 'nowrap' }}>
                                          {mainText}
                                        </span>
                                      );
                                    })()}
                                    {hoverSubIdx === i && (
                                      <>
                                        <button title="Edit" onClick={() => startEditConstraint('sub', j, i)} style={iconBtn}><Pencil size={14} color="#fb923c" /></button>
                                        <button title="Delete" onClick={() => deleteConstraint('sub', j, i)} style={iconBtn}><Trash2 size={14} color="#fb923c" /></button>
                                      </>
                                    )}
                                  </div>
                                  {(String((c as any)?.payoff || '').trim().length > 0) ? (
                                    <div style={{ fontSize: 14, color: '#94a3b8' }}>{(c as any).payoff}</div>
                                  ) : null}
                                </>
                              )}
                            </div>
                          ))}
                        </div>
                      );
                    })()}
                  </div>
                )}
              </div>
            ))
          ) : (
            <div style={{ opacity: 0.8, fontStyle: 'italic', marginTop: 6 }}>No sub fields yet.</div>
          )}
        </div>
      )}
    </div>
  );
};

export default MainDataWizard;
