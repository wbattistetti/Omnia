// Please write clean, production-grade TypeScript code.
// Avoid non-ASCII characters, Chinese symbols, or multilingual output.

/**
 * CONTRACT LAYER - generateCanonicalValues.ts
 *
 * Generates canonical value sets for semantic contracts.
 * Returns three types of examples: canonicalExamples, partialExamples, invalidExamples.
 *
 * Architecture:
 * - Pure function for merge logic (deterministic)
 * - Side effect: API call to backend (isolated)
 * - Non-destructive: preserves all existing contract fields
 * - Additive: only adds canonicalExamples field
 *
 * @see ARCHITECTURE.md for complete architecture documentation
 */

import type { SemanticContract } from '../../types/semanticContract';
import type { CanonicalValueSets, CanonicalExample } from '../../types/canonicalValueSets';
import type { GenerationProgress } from './types';

/**
 * Canonical values response from AI
 * Simplified structure with three arrays
 */
interface CanonicalValuesResponse {
  canonicalExamples: Array<{
    input: string;
    expected: Record<string, any> | string | number | null;
    description?: string;
  }>;
  partialExamples: Array<{
    input: string;
    expected: Record<string, any> | string | number | null;
    description?: string;
  }>;
  invalidExamples: Array<{
    input: string;
    expected: null;
    description?: string;
  }>;
}

/**
 * Validate AI response structure
 * Returns validated canonical values or null if invalid
 */
function validateCanonicalValues(data: any): CanonicalValuesResponse | null {
  if (!data || typeof data !== 'object') {
    return null;
  }

  const validated: CanonicalValuesResponse = {
    canonicalExamples: [],
    partialExamples: [],
    invalidExamples: []
  };

  // Validate canonicalExamples
  if (data.canonicalExamples !== undefined) {
    if (Array.isArray(data.canonicalExamples)) {
      validated.canonicalExamples = data.canonicalExamples.filter((item: any) => {
        return (
          item &&
          typeof item === 'object' &&
          typeof item.input === 'string' &&
          (item.expected !== undefined || item.expected === null)
        );
      });
    }
  }

  // Validate partialExamples
  if (data.partialExamples !== undefined) {
    if (Array.isArray(data.partialExamples)) {
      validated.partialExamples = data.partialExamples.filter((item: any) => {
        return (
          item &&
          typeof item === 'object' &&
          typeof item.input === 'string' &&
          (item.expected !== undefined || item.expected === null)
        );
      });
    }
  }

  // Validate invalidExamples
  if (data.invalidExamples !== undefined) {
    if (Array.isArray(data.invalidExamples)) {
      validated.invalidExamples = data.invalidExamples.filter((item: any) => {
        return (
          item &&
          typeof item === 'object' &&
          typeof item.input === 'string' &&
          item.expected === null
        );
      });
    }
  }

  // Ensure at least one canonical example
  if (validated.canonicalExamples.length === 0) {
    return null; // Invalid: must have at least one canonical example
  }

  return validated;
}

/**
 * Convert simplified AI response to CanonicalValueSets format
 * Maps canonicalExamples -> complete, partialExamples -> partial, invalidExamples -> stress
 */
function convertToCanonicalValueSets(
  response: CanonicalValuesResponse,
  outputFormat: 'object' | 'value'
): CanonicalValueSets {
  const convertExample = (item: any): CanonicalExample => {
    return {
      input: item.input,
      expected: item.expected,
      description: item.description
    };
  };

  return {
    complete: response.canonicalExamples.map(convertExample),
    partial: response.partialExamples.map(convertExample),
    incomplete: [], // Not generated by AI, can be added later
    ambiguous: [], // Not generated by AI, can be added later
    noisy: [], // Not generated by AI, can be added later
    stress: response.invalidExamples.map(convertExample)
  };
}

/**
 * Merge canonical values into contract (pure function)
 * Non-destructive: preserves all existing fields
 * Additive: only adds canonicalExamples field
 */
function mergeCanonicalValuesIntoContract(
  contract: SemanticContract,
  canonicalValues: CanonicalValueSets
): SemanticContract {
  // Create a deep copy to avoid mutating original
  const merged: SemanticContract = JSON.parse(JSON.stringify(contract));

  // Get output format
  const outputFormat = merged.outputCanonical?.format || 'value';

  // Merge canonical values
  // If contract already has canonicalExamples, merge arrays (non-destructive)
  if (merged.canonicalExamples) {
    // Merge complete examples
    const existingComplete = merged.canonicalExamples.complete || [];
    const newComplete = canonicalValues.complete || [];
    merged.canonicalExamples.complete = [...existingComplete, ...newComplete];

    // Merge partial examples
    const existingPartial = merged.canonicalExamples.partial || [];
    const newPartial = canonicalValues.partial || [];
    merged.canonicalExamples.partial = [...existingPartial, ...newPartial];

    // Merge stress examples
    const existingStress = merged.canonicalExamples.stress || [];
    const newStress = canonicalValues.stress || [];
    merged.canonicalExamples.stress = [...existingStress, ...newStress];

    // Preserve other existing arrays
    merged.canonicalExamples.incomplete = merged.canonicalExamples.incomplete || [];
    merged.canonicalExamples.ambiguous = merged.canonicalExamples.ambiguous || [];
    merged.canonicalExamples.noisy = merged.canonicalExamples.noisy || [];
  } else {
    // Add new canonicalExamples
    merged.canonicalExamples = canonicalValues;
  }

  // Ensure at least one complete example
  if (!merged.canonicalExamples.complete || merged.canonicalExamples.complete.length === 0) {
    throw new Error('Contract must have at least one canonical example');
  }

  // Update metadata
  merged.updatedAt = new Date();
  if (merged.version) {
    merged.version = merged.version + 1;
  } else {
    merged.version = 2;
  }

  return merged;
}

/**
 * Generate canonical values for a contract using AI
 *
 * This function:
 * 1. Calls backend API to get AI-generated canonical values
 * 2. Validates AI response
 * 3. Converts to CanonicalValueSets format
 * 4. Merges into contract (non-destructively)
 * 5. Returns contract with canonical values or original if generation fails
 *
 * @param contract - Semantic contract to generate values for
 * @param nodeLabel - Optional node label for context
 * @param onProgress - Optional progress callback
 * @returns Contract with canonical values or original if generation fails
 */
export async function generateCanonicalValuesForNode(
  contract: SemanticContract,
  nodeLabel?: string,
  onProgress?: (progress: GenerationProgress) => void
): Promise<SemanticContract> {
  if (onProgress) {
    onProgress({
      currentStep: 0,
      totalSteps: 1,
      currentNodeId: '',
      currentNodeLabel: nodeLabel || contract.entity.label,
      currentAction: 'Generating canonical values with AI...',
      percentage: 0
    });
  }

  try {
    // Call backend API
    const response = await fetch('/api/nlp/generate-canonical-values', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contract,
        nodeLabel,
        provider: localStorage.getItem('omnia.aiProvider') || 'openai',
        model: localStorage.getItem('omnia.aiModel') || undefined
      })
    });

    if (!response.ok) {
      console.warn('[generateCanonicalValues] API call failed:', response.statusText);
      return contract; // Fallback to original
    }

    const data = await response.json();

    if (!data.success || !data.canonicalValues) {
      console.warn('[generateCanonicalValues] AI generation failed or returned no canonical values');
      return contract; // Fallback to original
    }

    // Validate canonical values structure
    const validated = validateCanonicalValues(data.canonicalValues);

    if (!validated) {
      console.warn('[generateCanonicalValues] Invalid canonical values structure, returning original contract');
      return contract; // Fallback to original
    }

    // Convert to CanonicalValueSets format
    const outputFormat = contract.outputCanonical?.format || 'value';
    const canonicalValueSets = convertToCanonicalValueSets(validated, outputFormat);

    // Merge into contract (pure function)
    const merged = mergeCanonicalValuesIntoContract(contract, canonicalValueSets);

    if (onProgress) {
      onProgress({
        currentStep: 1,
        totalSteps: 1,
        currentNodeId: '',
        currentNodeLabel: nodeLabel || contract.entity.label,
        currentAction: `Generated ${validated.canonicalExamples.length} canonical examples`,
        percentage: 100
      });
    }

    return merged;

  } catch (error) {
    console.warn('[generateCanonicalValues] Error during generation:', error);
    return contract; // Fallback to original
  }
}
